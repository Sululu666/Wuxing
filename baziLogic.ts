import { BaZiState, FiveElement, ElementStrength, Stem, Branch, DetailedAnalysis, CharEnergyDetail } from './types';
import { STEMS, BRANCHES, STEM_OPTIONS, BRANCH_OPTIONS, ELEMENT_CN } from './constants';

// Basic mapping of generating and controlling cycles
const GENERATING_CYCLE: Record<FiveElement, FiveElement> = {
  [FiveElement.Wood]: FiveElement.Fire,
  [FiveElement.Fire]: FiveElement.Earth,
  [FiveElement.Earth]: FiveElement.Metal,
  [FiveElement.Metal]: FiveElement.Water,
  [FiveElement.Water]: FiveElement.Wood,
};

const CONTROLLING_CYCLE: Record<FiveElement, FiveElement> = {
  [FiveElement.Wood]: FiveElement.Earth,
  [FiveElement.Earth]: FiveElement.Water,
  [FiveElement.Water]: FiveElement.Fire,
  [FiveElement.Fire]: FiveElement.Metal,
  [FiveElement.Metal]: FiveElement.Wood,
};

// Relation check helpers
const isGeneratedBy = (child: FiveElement, parent: FiveElement) => GENERATING_CYCLE[parent] === child;
const isControlledBy = (victim: FiveElement, attacker: FiveElement) => CONTROLLING_CYCLE[attacker] === victim;
const generates = (parent: FiveElement, child: FiveElement) => GENERATING_CYCLE[parent] === child;
const controls = (attacker: FiveElement, victim: FiveElement) => CONTROLLING_CYCLE[attacker] === victim;

// Calculate detailed energy state for each character
export const calculateDetailedEnergy = (bazi: BaZiState): DetailedAnalysis => {
  const analysis: DetailedAnalysis = {};

  // 1. Identify the Month Branch Element (The Commander)
  const monthBranchConfig = BRANCHES[bazi.month.branch];
  const seasonElement = monthBranchConfig.element;

  // Helper to calculate state for a single character
  const analyzeChar = (
    id: string,
    position: string,
    element: FiveElement,
    char: string,
    isBranch: boolean,
    pillarIndex: number, // 0=Year, 1=Month, 2=Day, 3=Hour
    hiddenStems?: Stem[]
  ): CharEnergyDetail => {
    let score = 0; // Base existence score
    const factors: string[] = [];
    let seasonStatus = "平 (中和)"; // Neutral

    const elCN = ELEMENT_CN[element];
    const seasonCN = ELEMENT_CN[seasonElement];

    // --- A. De Ling (Season Support) ---
    // Wang (Same as Season), Xiang (Generated by Season), Xiu (Generates Season), Qiu (Controls Season), Si (Controlled by Season)
    if (element === seasonElement) {
      score += 40;
      seasonStatus = "旺 (当令)";
      factors.push(`得令: 生于${seasonCN}月，${elCN}气最旺。`);
    } else if (isGeneratedBy(element, seasonElement)) {
      score += 30;
      seasonStatus = "相 (得生)";
      factors.push(`得生: 月令${seasonCN}生${elCN}，元气充足。`);
    } else if (generates(element, seasonElement)) {
      score -= 10;
      seasonStatus = "休 (泄气)";
      factors.push(`泄气: ${elCN}生月令${seasonCN}，能量消耗。`);
    } else if (controls(element, seasonElement)) {
      score -= 15;
      seasonStatus = "囚 (受困)";
      factors.push(`受困: ${elCN}克月令${seasonCN}，耗费气力。`);
    } else if (isControlledBy(element, seasonElement)) {
      score -= 20;
      seasonStatus = "死 (受克)";
      factors.push(`受克: 月令${seasonCN}克${elCN}，受制严重。`);
    }

    // --- B. De Di (Root/Location Support) ---
    // Check if this element has roots in ANY of the branches (checking hidden stems too)
    const branchKeys: (keyof BaZiState)[] = ['year', 'month', 'day', 'hour'];
    let rootCount = 0;

    branchKeys.forEach((k) => {
      const b = bazi[k].branch;
      const branchConfig = BRANCHES[b];

      let hasRoot = false;
      // Main Qi check
      if (branchConfig.element === element) hasRoot = true;
      // Hidden Stem check
      if (!hasRoot && branchConfig.hiddenStems) {
        hasRoot = branchConfig.hiddenStems.some(s => STEMS[s].element === element);
      }

      if (hasRoot) {
        rootCount++;
        // Sitting on root (Day Stem on Day Branch)
        if (!isBranch && k === 'day' && position.includes("日")) {
          score += 15;
          factors.push("坐支有根: 日主坐下得地，根基稳固。");
        }
      }
    });

    if (rootCount > 0) {
      score += (rootCount * 10);
      factors.push(`得地 (通根): 在${rootCount}个地支中有根气。`);
    } else if (!isBranch) {
      score -= 10;
      factors.push("无根 (虚浮): 地支无根，如同水中浮萍。");
    }

    // --- C. De Shi (Formation/Peer Support) ---
    // Count how many same or generating elements exist in the chart
    let supportCount = 0;
    const allPillars: (keyof BaZiState)[] = ['year', 'month', 'day', 'hour'];
    allPillars.forEach(p => {
      const sEl = STEMS[bazi[p].stem].element;
      const bEl = BRANCHES[bazi[p].branch].element;
      if (sEl === element || isGeneratedBy(element, sEl)) supportCount++;
      if (bEl === element || isGeneratedBy(element, bEl)) supportCount++;
    });
    // Remove self from count
    supportCount--;

    if (supportCount >= 3) {
      score += 15;
      factors.push(`得势 (朋党): 有${supportCount}个同党或印星助阵。`);
    } else if (supportCount <= 1) {
      score -= 5;
      factors.push("孤立: 缺乏印比帮扶，势单力薄。");
    }

    // Cap score 0-100 (can go slightly over visual cap internally, but we clamp for display)
    return {
      id,
      position,
      char,
      element,
      baseScore: Math.max(5, Math.min(100, score)),
      factors,
      seasonStatus,
      hiddenStems
    };
  };

  // Iterate pillars
  const pillars: { key: keyof BaZiState, label: string }[] = [
    { key: 'year', label: '年' }, // Year
    { key: 'month', label: '月' }, // Month
    { key: 'day', label: '日' }, // Day
    { key: 'hour', label: '时' } // Hour
  ];

  pillars.forEach((p, idx) => {
    const stemChar = bazi[p.key].stem;
    const branchChar = bazi[p.key].branch;

    analysis[`${p.key}-stem`] = analyzeChar(
      `${p.key}-stem`,
      `${p.label}干`,
      STEMS[stemChar].element,
      STEMS[stemChar].char,
      false,
      idx
    );

    analysis[`${p.key}-branch`] = analyzeChar(
      `${p.key}-branch`,
      `${p.label}支`,
      BRANCHES[branchChar].element,
      BRANCHES[branchChar].char,
      true,
      idx,
      BRANCHES[branchChar].hiddenStems
    );
  });

  return analysis;
};

// Aggregate detailed analysis into simple strength map for compatibility
export const calculateBaseStrengths = (bazi: BaZiState): ElementStrength => {
  const detailed = calculateDetailedEnergy(bazi);
  const strengths: ElementStrength = {
    [FiveElement.Wood]: 0,
    [FiveElement.Fire]: 0,
    [FiveElement.Earth]: 0,
    [FiveElement.Metal]: 0,
    [FiveElement.Water]: 0,
  };

  Object.values(detailed).forEach(detail => {
    strengths[detail.element] += detail.baseScore;
  });

  return strengths;
};


export const getSimulationModifiers = (injectedElement: FiveElement | null): Record<FiveElement, number> => {
  const modifiers: Record<FiveElement, number> = {
    [FiveElement.Wood]: 0,
    [FiveElement.Fire]: 0,
    [FiveElement.Earth]: 0,
    [FiveElement.Metal]: 0,
    [FiveElement.Water]: 0,
  };

  if (!injectedElement) return modifiers;

  modifiers[injectedElement] += 40;
  const child = GENERATING_CYCLE[injectedElement];
  modifiers[child] += 25;
  const enemy = CONTROLLING_CYCLE[injectedElement];
  modifiers[enemy] -= 30;

  // Parent leaked
  const parent = Object.keys(GENERATING_CYCLE).find(k => GENERATING_CYCLE[k as FiveElement] === injectedElement) as FiveElement;
  modifiers[parent] -= 15;

  // Master exhausted
  const master = Object.keys(CONTROLLING_CYCLE).find(k => CONTROLLING_CYCLE[k as FiveElement] === injectedElement) as FiveElement;
  modifiers[master] -= 15;

  return modifiers;
};

export const normalizeOpacity = (base: number, modifier: number): number => {
  let value = base + modifier;
  // Adjusted for new scoring scale (avg score ~50-60, max ~120)
  let opacity = value / 100;
  if (opacity < 0.2) opacity = 0.2;
  if (opacity > 1.0) opacity = 1.0;
  return opacity;
};

export const getRandomBaZi = (): BaZiState => {
  const rStem = () => STEM_OPTIONS[Math.floor(Math.random() * STEM_OPTIONS.length)];
  const rBranch = () => BRANCH_OPTIONS[Math.floor(Math.random() * BRANCH_OPTIONS.length)];
  return {
    year: { stem: rStem(), branch: rBranch() },
    month: { stem: rStem(), branch: rBranch() },
    day: { stem: rStem(), branch: rBranch() },
    hour: { stem: rStem(), branch: rBranch() },
  };
};
